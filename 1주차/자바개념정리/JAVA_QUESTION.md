
# 자바 핵심 개념 정리 1
<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
- 기본 8개의 타입을 제공 </br>
문자형 : char(2byte)  </br>
정수형 : byte(1byte) , short(2byte), int(4byte), long(8byte)</br>
실수형 : float(4byte), double(8byte)</br>
논리형 : boolean(1byte)</br> 
cf. 데이터를 다루는 최소 단위가 byte라 boolean을 1bit가 아닌 1byte로 다룸
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
<b>오버라이딩(Overriding)</b></br>
- 슈퍼 클래스에서 받은 메소드를 자식 클래스에서 재정의 하는 것을 말함</br>
    - 서브 클래스에서 슈퍼 클래스에 선언된 메소드를 중복 작성하여 슈퍼 클래스에 작성된 메서드를 무시하고 서브 클래스에서 중복 작성된 메서드를 실행시키는 것</br>
- 이때 메소드의 이름, 매개변수의 개수, 타입, 그리고 리턴 타입 등이 모두 동일해야 함.</br>
- 실행시간에 오버라이딩된 메소드를 찾아 호출하는 동적바인딩</br></br>
<b>오버로딩(Overloading)</b></br>
- 같은 클래스나 상속 관계에 있는 클래스에 동일한 이름의 메소드가 중복 작성되는 것을 지칭.</br>
- 이때 메소드의 이름은 반드시 동일해야하며, 매개변수의 개수나 타입은 달라야 함.</br>
- 컴파일 과정에서 어떤 메서드를 호출할지 결정되는 정적 바인딩</br></br>
오버로딩과 오버라이딩을 통해 객체 지향의 다형성을 구현할 수 있음</br>
또한, 코드 중복을 줄이고 기능 확장의 장점을 가짐</br>
</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
- 컴퓨터 프로그래밍 방식 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법</br>
- 프로그래밍을 여러 개의 독립된 단위인 ‘객체’들의 모임으로 보는 것을 말함.</br>
- 각 객체들은 메시지를 주고 받고, 데이터를 처리할 수 있음.
</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
<b>추상 클래스 (Is - a)(상속)</b></br>
    - 클래스 내에 ‘추상메소드’가 하나 이상 포함되거나 abstract 키워드로 정의된 경우를 말함.</br></br>
<b>인터페이스(Has -a)(포함)</b></br>
    - interface 키워드로 선언되는 것</br></br>
<b>**공통점**</b></br>
    - 둘 다 비슷하게 extends 나 implements를 사용하여 서브 클래스와 구현 클래스를 정의하고, 서브 클래스에서 추상메소드를 구현하도록 강제함</br>
    - 추상 클래스와 인터페이스 모두 객체를 생성할 수 없고 서브, 구현 클래스를 통해 객체를 생성할 수 있음.</br>
    - 이를 통해 프로그램의 유지 보수성을 높일 수 있음</br></br>
<b>**차이점**</b></br>
    - 애초에 **존재 목적**이 다름</br>
        - <b>추상 클래스</b> </br>
        >'상속'을 통해 부모의 기능을 이용하고 확장하는 데 목적이 있음 </br>
        > 즉, 상속을 위한 슈퍼 클래스로 활용하기 위함</br>
        -<b> 인터페이스</b></br>
        > 메소드의 선언만 되어있어 그 함수의 구현을 강제하여 구체적인 클래스에 의존하지 않고 객체지향의 특징인 **다형성**을 추구하는데 목적이 있음.</br>
        > 선언과 구현을 분리하여 유연한 설계를 위함**</br>
    - 이 외에도 추상 클래스는 다중 상속이 불가하고, 인터페이스는 다중 상속이 가능하다는 점, 그리고 추상 클래스는 생성자, 필드, 일반 메소드를 포함할 수 있는 반면에 인터페이스는 이것들을 가질 수 다는 차이 존재.
</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
- **GC(가비지 컬렉터)란?**</br>
    - 힙 메모리 관리를 위해 참조되고 있지 않은 객체들을 찾아 메모리에서 삭제하는 역할을 하는 시스템 
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
- JVM은 클래스 로더와 실행 엔진, 가비지 컬렉터를 포함하고 있고, 동작 방식은 다음과 같음 </br></br>
1. 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당</br>
2. 자바 컴파일러가소스코드를 바이트 코드로 컴파일함</br>
3. 클래스 로더를 통해 JVM Runtime Data Area로 로딩</br>
4. Runtime Data Area에 로딩된 .class들은 실행엔진을 통해 해석됨</br>
5. 해석된 바이트 코드는 Runtime Data Area의 각 영역에 배치되어 수행되며 이 과정에서 실행엔진에 의해 가비지 컬렉터의 작동과 스레드 동기화가 이뤄짐.</br>
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
불변객체란 객체 생성 이후에 내부의 상태가 변하지 않는 객체를 말함</br></br>
final은 이러한 불변성 확보를 위해 사용되는 키워드를 말하며, 3가지 용도롤 사용됨</br>
- final로 선언된 클래스는 더 이상 상속되지 않으며,</br> 
final로 선언된 메소드는 더 이상 오버라이딩될 수 없고, </br> 
final로 선언된 필드는 상수로서, 실행 중에 값을 변경할 수 없음.</br></br>
불변객체 및 final을 사용하는 이유</br>
1. 불변이라는 특성 덕분에 동기화를 고려하지 않아도 되어 멀티 스레드 환경에 유용.</br>
2. 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있음</br>
3. 불변 객체는 내부 상태가 변경되지 않아, Map의 Key와 Set의 요소로 사용하기 적합</br>
4. 한 번 할당하면 같은 객체 계속 호출하더라도 새롭게 할당되지 않아 GC의 성능을 높일 수 있음</br>
</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
자바의 메모리 영역은 크게 3가지로 이루어져 있음</br></br>
1. Heap 영역</br>
    - new를 사용해 생성된 객체와 참조형 데이터 객체의 실제 데이터가 저장됨</br>
    - 호출이 종료되어도 삭제되지 않고 GC에 의해 메모리에서 해제됨</br>
    - 쓰레드 개수와 상관 없이 단 하나만 존재</br></br>
2. Stack 영역</br>
    - Heap영역 참조형 데이터의 주소값과, 객체의 주소 값이 저장됨</br>
    - 기본 자료형, 지역 변수, 매개변수가 저장됨</br>
    - 메소드 호출될 때 메모리에 할당되고 메소드 종료시 메모리에서 삭제됨</br>
    - 각 쓰레드는 자신만의 Stack을 가짐</br></br>
3. Static(Method) 영역</br>
    - JVM이 실행될 때나 CLass가 로딩될 때 생성됨</br>
    - Class의 정보, Static 변수(클래스 변수), 생성자, 메소드 등을 저장</br>
    - 이 영역에 있는 것은 어디서든 접근이 가능함</br>
    - 프로그램 종료됙 전까지 메모리 상에 존재함</br>
</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
이 둘은 저장되는 저장공간(메모리)의 차이</br></br>
- new String() </br>
    : 객체로 생성되어 Heap 메모리 영역에 저장됨</br>
    : 항상 새로운 주소를 할당 받음</br></br>
- 리터럴(" ") </br>
    : Heap 내의 Stirng constant pool 이라는 영역에 저장됨</br>
    : 같은 값이 이미 존재한다면 이전과 동일한 주소를 가짐</br>

</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
람다식: 간결한 형식의 코드 뭉치</br>
람다식 표현 :  (전달값1, 전달값2, ...) -> { 코드 }</br>
- 접근 제어자, 반환 값, 메소드 이름 필요X</br>
- 파라미터의 자료형 필요X </br>
- 전달 값 1개인 경우, 괄호 필요X</br>
- 문장 한 줄인 경우, 중괄호&세미콜론 필요X 자동으로 그 문장 반환</br>
    ----단, 리턴이 포함된 경우 괄호 생략 불가</br>
    
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
스트림(Stream) : 람다를 활용할 수 있는 기술 중 하나로 '데이터의 흐름'이라고 생각하면 됨</br>
- 이전에 반복문과 iterator를 통해 순회하던 것을 람다식과 스트림을 이용하여 매우 간결하게 순회하고 또 데이터를 처리할수 있음</br></br>
스트림의 동작 흐름</br>
- 생성-> 중개 연산(변환) -> 최종 연산(사용)</br>
- 생성: 컬렉션, 배열, 가변 매개변수, 람다 표현식, 파일 등등 다양한 데이터 소스에서 생성할 수 있음</br>
- 중개 연산(변환): 초기 스트림은 중개 연산을 통해 또 다른 스트림으로 변환됨 (ex. filter(),map(),limit(),sorted()...)</br>
- 최종 연산(사용): 각 요소를 소모하여 결과 표시하고 해당 스트림은 더이상 사용 불가 (ex. foreEach(), reduce(), count(), sum()...)

</div>
</details>
<br>
