
# 자바 핵심 개념 정리 1
<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
자바에서 제공하는 원시 타입은 정수형, 실수형, 문자형, 논리형이 있다. 
정수형 타입에는 byte, short, int, long이 있고 각각 byte는 1바이트, short는 2바이트, int는 4바이트, long은 8바이트를 차지한다. 
실수형 타입에는 float과 double이 있고 float은 4바이트, double은 8바이트이다. 
문자형 타입에는 2바이트를 차지하는 char가 있다. 
논리형 타입에는 1바이트를 차지하는 boolean이 있다.
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
오버라이딩과 오버로딩은 자바에서 다형성을 구현하는 방식이다.
오버라이딩(OverRiding)은 상위 클래스의 메서드를 하위 클래스에서 재정의하여 사용하는 것이다.
오버로딩(OverLoading)은 이름이 같은 메서드를 매개변수의 타입과 갯수에 따라 여러 개를 정의하는 것이다. 메서드를 호출할 때의 매개변수에 따라 맞는 메서드가 호출되는 방식이다.
</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
객체지향 프로그래밍은 현실 세계를 모델링하여 상태와 행동으로 구성된 객체를 만들어서 그 고유한 객체들간의 상호작용으로 프로그램을 만드는 접근법이다.

객체지향 프로그래밍의 핵심특징은 추상화(Abstraction),상속(Inheritance), 다형성(Polymorphism), 캡슐화(Encapsulation)이다.
(1)추상화
  핵심적인 부분만을 표현하기 위해 클래스들의 공통적인 특성(변수, 메서드)들을 묶어서 표현하는 것
(2)상속
  부모 클래스에 정의된 변수 및 메서드를 자식 클래스에서 상속받아 사용하는 것
(3)다형성
  클래스의 메서드 등을 다양한 형태로 표현하는 것
(4)캡슐화
  데이터와 코드를 외부에서는 알 수 없게 은닉하고, 메서드를 통해서만 사용이 가능하게 하는 것

객체지향 프로그래밍의 장점은 코드의 재사용이 용이하고 유지,보수가 쉽다는 점이다.
</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
추상클래스와 인터페이스는 객체지향 프로그래밍의 추상화와 다형성을 구현하는 데 사용되는 두가지 개념이다.

추상클래스
 추상클래스는 하위 크래스들의 공통점들을 모아 추상화하여 만든 클래스이다.
 추상 클래스는 내용이 구현되지 않은 메소드인 추상 메소드를 하나 이상 포함하고 일반적인 필드, 메서드, 생성자도 가질 수 있다. 추상 클래스는 직접 객체를 생성할 수 없으며, 추상 클래스를 상속받은 하위 클래스에서 추상 메서드를 오버라이드하여 사용한다.

인터페이스
 인터페이스는 추상 메소드와 상수만을 정의하는 특별한 형태의 추상 클래스이다. 인터페이스는 객체를 생성할 수 없으며, 클래스가 인터페이스를 구현(implement)하여 인터페이스 내의 모든 메소드를 오버라이드해야 한다. 

차이점 
(1) 단일상속/다중상속
 추상클래스는 단일상속만 가능하다. 하나의 클래스는 오직 하나의 추상클래스만을 상속받을 수 있다. 
 그러나 인터페이스는 다중 상속이 가능하다. 하나의 클래스가 여러 개의 인터페이스를 구현할 수 있다.

(2) 사용목적
 추상 클래스는 extends 키워드를 사용해서 자신의 기능들을 하위 클래스로 확장 시키는 개념이다. 추상 클래스는 상속 받을 클래스들이
 공통으로 가지는 메소드와 필드가 많을 때 중목 멤버를 통합하는 역할을 한다.
 반면, 인터페이스는 부모 자식 관계에 얽매이지 않고, 공통 기능이 필요한 클래스가 구현하는 것을 목적으로 한다. 서로 관련성 없는 클래스들의 공통 기능을 묶어 추상화할 때 사용되는 것이다.
</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
가비지 컬렉션(gc)
 가비지 컬렉션은 Heap 영역에서 동적으로 할당된 메모리 중에서 사용되지 않는 메모리 객체를 찾아내서 제거하는 과정을 말한다. 이 과정은 프로그래머가 명시적으로 메모리를 해제하는 것이 아니라, 프로그램 실행 도중에 JVM에 의해 자동으로 수행된다.

Mark And Sweep
 Mark And Sweep 알고리즘은 가비지 컬렉션이 동작하는 원리이다. 가비지 컬렉션에서는 해당 객체에 접근 가능한지에 대한 여부(참조되고 있는지 여부)를 메모리 해제의 기준으로 삼고 있어 아무데서도 참조되지 않는 객체를 가비지(gabage)로 판단하여 제거한다.
 Mark And Sweep은 ‘Mark-Sweep-Compact’ 단계로 나뉜다.
    -Mark 단계는 메모리 영역을 스캔하면서 어떤 객체들을 살려둘지 식별하는 단계이다.
    -Sweep 단계는 참조되지 않는 객체들을 제거하고 살아있는 객체들만 메모리를 점유하고 있도록 하는 단계이다.
    -Compact 단계에서는 Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다.
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
JVM은 자바 가상 머신(Java Virtual Machine)으로 자바 어플리케이션을 실행하는 가상 머신이다.

JVM의 동작방식
(1) 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받는다.

(2) 자바 컴파일러(javac)가 자바 소스코드(.java)를 자바 바이트 코드(.class)로 컴파일한다.

(3) Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 Runtime Data Area에 올린다.
 -클래스 로더(Class Loader)는 JVM 내로 클래스 파일(*.class)을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 즉, 로드된 바이트 코드(.class)들을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치한다.
 
 -클래스를 메모리에 올리는 로딩 기능은 한번에 메모리에 올리지 않고, 어플리케이션에서 필요한 경우 동적으로 메모리에 적재하게 된다.
 -클래스 파일의 로딩 순서는 다음과 같이 3단계로 구성된다.(Loading → Linking → Initialization)
   - Loading(로드) : 클래스 파일을 가져와서 JVM의 메모리에 로드한다.
   - Linking(링크) : 클래스 파일을 사용하기 위해 검증하는 과정이다.
        Verifying(검증) : 읽어들인 클래스가 JVM 명세에 명시된 대로 구성되어 있는지 검사한다.
        preparing(준비) : 클래스가 필요로 하는 메모리를 할당한다.
        Resolving(분석) : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
   - Initialization(초기화) : 클래스 변수들을 적절한 값으로 초기화한다.( static 필드들을 설정된 값으로 초기화 등 )

(4) Runtime Data Area에 로딩 된 바이트 코드는 Execution Engine을 통해 해석된다.
 -실행 엔진(Execution Engine)은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다.
 -자바 바이트 코드(*.class)는 기계가 바로 수행할 수 있는 언어보다는 가상머신이 이해할 수 있는 중간 레벨로 컴파일된 코드이다. 그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다.

(5) 이 과정에서 Execution Engine에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어진다.
 -Garbage Collector(가비지 컬렉터)는 프로그램이 동적으로 할당한 메모리 영역 중에서 사용하지 않는 영역을 자동으로 해제하는 역할을 한다. Execution Engine은 프로그램이 실행되는 동안 Garbage Collector를 호출하여 불필요한 메모리를 정리하고, 이를 효율적으로 관리한다.
 -Thread 동기화는 다중 스레드 환경에서 발생하는 문제를 해결하기 위한 기술이다. 여러 스레드가 동시에 공유 자원에 접근할 때 발생하는 데이터 불일치 문제나 경쟁 조건을 해결하기 위해 스레드 간의 작업을 조율하는 것을 말한다. Execution Engine은 다중 스레드 프로그램에서 동기화 작업을 지원하고 스레드 간의 상호작용을 관리한다.
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
불변객체
 불변 객체는 객체 생성 이후 상태가 변하지 않는, 변경할 수 없는 객체를 말한다. 불변 객체는 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다. 대표적으로 Java의 String, Integer, Double 등이 있다.

 방어적 복사(defensive copy)는 객체의 주소를 복사하지 않고 객체의 내부 값을 참조하여 복사하는 방법이다. 이렇게 복사한 복사본은 원본과 다른 객체를 참조하게 되지만, 해당 객체 내부에 있는 객체들은 원본과 동일한 주소를 참조한다.
 
 이와 같이 불변객체를 만들기 위해서 java에서는 final 키워드를 제공한다. 변수 혹은 클래스에 final 키워드를 붙이면 불변객체를 만들 수 있다.

불변 객체를 사용하는 이유
 (1) 멀티 쓰레드 환경에서 동기화를 고려하지 않아도 된다.
    멀티 쓰레드 환경에서 공유 자원이 불변이라면 항상 동일한 값을 반환하기 때문에 동기화를 고려하지 않아도 된다. 이를 통해 안정성을 보장할 수 있다.
 
 (2) 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.
   불변 객체를 사용하면 어떠한 예외가 발생하여도 불안정한 상태에 빠지지 않고 메소드 호출 전의 상태를 유지할 수 있다.
 
 (3) 타인이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
   불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 이용할 수 있다. 마찬가지로 다른 사람도 내가 작성한 메소드를 호출하여도 값이 변하지 않음을 보장받을 수 있다.
</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
자바 프로그램이 실행되면 JVM(자바 가상 머신)은 OS로부터 메모리를 할당받고, 그 메모리를 용도에 따라서 여러 영역으로 나누어 관리한다.
자바의 메모리 공간은 크게 Method(Static) 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 각 영역에 할당된다.

Method(Static) 영역 : 멤버 변수(필드), 클래스 변수(Static 변수), 상수(final), 생성자(constructor)와 메소드(method)등을 저장하는 공간.
     - Method 영역에 있는 것은 어느 곳에서나 접근이 가능하다.
     - Method 영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.

Stack 영역 : 메소드 내에서 정의하는 기본 자료형에 해당되는 지역변수와 매개변수 데이터 값이 저장되는 공간.
     - 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. 
     - LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.

Heap 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 저장되는 공간으로 프로그램 상에서 데이터를 저장하기 위해 동적으로 할당하여 
     사용하는 영역.
     - Stack 영역과 다르게 보관되는 메모리가 호출이 끝나더라도 삭제 되지 않고 유지된다.
</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
new String()과 리터럴(" ") 두 가지 모두 String 객체를 생성하지만 저장되는 메모리 구조에 차이가 있다.

new String()은 new 키워드로 인스턴스를 생성하기 때문에 Heap 메모리 영역에 저장된다. new String()으로 같은 String 값을 가지는 객체를 여러 개 생성할 경우, Heap 영역에는 생성한 객체의 수만큼의 String값이 저장된다.

반면, 리터럴(" ")은 Heap 안에 있는 String Pool 영역에 저장된다. 리터럴로 생성된 같은 String 값을 가지는 객체들은 같은 주소값을 참조한다. 즉, 리터럴(" ")로 같은 String 값을 가지는 객체를 여러 개 생성할 경우, String Pool 영역의 한개의 String값을 여러 객체가 참조하는 것이다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
람다
 람다 표현식(lambda expression)이란 익명 함수의 한 형태이다. 간단히 말해 자바의 메소드를 간결한 함수 식으로 표현한 것이다. 람다 표현식은 람다 파라미터, 화살표, 람다 바디로 구성된다. 자바에서 메서드를 람다식으로 표현하면 메서드의 이름과 반환값을 생략할 수 있고 이를 변수에 넣어 자바 코드가 매우 간결해지는 장점이 있다.

 int add(int a, int b) {
   return a+b;
 } 
 위와 같은 메소드 표현식을 메서드 타입, 메서드 이름, 매개변수 타입, 중괄호, return 문을 생략하고, 화살표 기호를 넣음으로써 코드를 함축하여 아래와 같은 람다식으로 나타낼 수 있는 것이다.
 (a, b) → a+b;


함수형 인터페이스(Functional Interface)
 함수형 인터페이스(Functional Interface)는 딱 하나의 추상 메서드를 지정하는 인터페이스다. 이러한 인터페이스는 람다식을 사용하여 간단한 구현하여 사용할 수 있다.

 public interface Runnable {
    void run();
 }
 위와 같은 함수형 인터페이스를 아래와 같이 람다식으로 구현할 수 있다.
 Runnable runnable = () -> System.out.println("Hello");

 위 람다 표현식은 아래와 같은 익명 클래스의 인스턴스로 취급할 수 있다. 
 Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
 };

 위와 같은 방식으로 자바에서 함수형 인터페이스의 추상 메서드를 람다 표현식으로 직접 구현하여 전달할 수 있다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
스트림(Stream)
 자바에서의 스트림(Stream)은 데이터를 다루는데 사용되는 추상화된 개념이다. 스트림은 데이터의 연속적인 흐름을 나타내며, 람다식을 이용하여 데이터의 소스(예: 배열, 컬렉션, 파일 등)를 조작 및 가공, 변환하여 원하는 값으로 반환해주는 인터페이스를 의미한다.

스트림의 특징
 (1)원본의 데이터를 변경하지 않는다.
   스트림은 원본 데이터를 조회하여 별도의 Stream 객체로 생성한다. 그렇기 때문에 배열의 정렬이나 필터링 작업을 하더라도 원본 데이터가 변경되지 않는다.
 (2)스트림은 재사용이 불가능하여 일회용으로 사용된다.
   스트림은 이미 사용이 되어 닫혔다면 재사용이 불가능하여 새로운 Stream을 생성해주어야 한다.
 (3)스트림은 내부 반복으로 작업을 처리한다.
   스트림 내에서 내부적으로 반복문을 처리하기에 간결한 소스코드의 작성이 가능하다.

스트림의 사용과정
 Stream의 객체를 구성하고자 할 때에 "Stream 생성 → 중간 연산→ 최종 연산" 의 세 단계의 과정을 통하여서 처리가 이루어진다.
</div>
</details>
<br>
