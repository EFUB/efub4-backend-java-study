
# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">
  * POJO: Plain Old Java Object. POJO는 객체 지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다. 즉, 자바 언어 스펙 외의 특정 기술(ex. 프레임워크, 라이브러리, 별개의 클래스)에 대한 종속성이 없어 객체 단독으로 사용할 수 있는 객체를 의미한다.
  <br>
</div>
</details>
<br>

<details>
<summary>제네릭이 무엇인가요? 컬렉션 클래스에서 제네릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">
  * 제네릭(Generic): 제네릭이란 자바에서 클래스와 메서드를 정의할 때 타입 파라미터를 사용하는 것이다. 클래스 또는 메서드 내부에서 사용할 데이터 타입을 미리 지정하지 않고 사용하는 시점에 구체적인 데이터 타입을 지정한다.
  <br>
  * 컬렉션 클래스에서 제네릭을 사용하는 이유: 컴파일 시에 강한 타입 체크를 통해 타입 안정성을 보장한다(런타임에 발생할 수 있는 ClassCastException을 컴파일 타임에서 체크 가능하다). 다양한 타입의 데이터를 다룰 수 있어 코드 재사용성이 향상된다. 컴파일러가 타입 변환을 수행하므로 불필요한 캐스팅을 제거하여 코드가 간결해진다.
  <br>
</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">
  * static 변수 선언부 -> 필드 변수 선언부 -> 생성자 block
  <br>
  1. static 변수 선언부: 클래스가 로드될 때 변수가 제일 먼저 초기화
  <br>
  2. 필드 변수 선언부: 객체가 생성될 때 생성자 block보다 앞서 초기화
  <br>
  3. 생성자 block: 객체가 생성될 때 JVM이 내부적으로 locking(thread-safe 영역)
  <br>
  (참고) 클래스 멤버 변수 초기화 방법: (1)명시적 초기화, (2)생성자, (3)초기화 블럭(인스턴스 초기화 블럭: 인스턴스 변수 초기화, 클래스 초기화 블럭: 클레스 변수 초기화)
  <br>
</div>
</details>
<br>

<details>
<summary>직렬화(Serialization)란 무엇인가요?</summary>
<div markdown="1">
  * 컴퓨터 과학에서 직렬화: 현재 데이터 구조나 오브젝트 상태를 영속적으로 저장하거나 다른 환경으로 전달하기 위해 어떠한 정해진 포맷으로 변환하는 프로세스. 
  <br>
  * 자바에서 직렬화: JVM 메모리에 상주(힙or스택) 되어 있는 객체 데이터를 byte 형태로 변환하는 기술. 객체의 내용을 byte 단위로 변환하면 파일 또는 네트워크를 통해 스트림(송수신)이 가능하게 된다. 직렬화를 사용함으로서 자바 시스템 내부에서 사용되는 객체 또는 데이터의 상태를 저장하거나 외부의 자바 시스템에 전송할 수 있게 된다.
  <br>
</div>
</details>
<br>

<details>
<summary>[복습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">
  * SRP(Single Responsibility Principle): 단일 책임의 원칙
 <br>
 - 객체는 오직 하나의 책임을 가져야 한다. 한 클래스가 하나의 기능을 담당하여 하나의 책임을 수행하는 데 집중되어있어야 한다.
 <br>
 * OCP(Open-Closed Principle): 개방 폐쇄 원칙
 <br>
 - 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다. 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야 한다.
 <br>
 * ISP(Interface Segregation Principle): 인터페이스 분리 원칙
 <br>
 - 인터페이스를 클라이언트 기준으로 분리해야 한다. 즉, 클라이언트가 자신이 호출하지 않는 메소드에 의존하지 않아야 한다.
 <br>
 * LSP(Liskov Substitution Principle): 리스코프 치환 원칙
 <br>
 - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다. 즉 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 작동해야 한다.
 <br>
 * DIP(Dependency Inversion Principle): 의존성 역전 원칙
 <br>
 - 객체는 구체적인 구현이 아닌 구체적인 구현이 아닌 추상화(추상 클래스, 인터페이스)에 의존해야 한다.
 <br>
</div>
</details>
<br>

<details>
<summary>DI는 무엇일까요?</summary>
<div markdown="1">
  * DI(Dependency Injection, 의존성 주입): 객체를 직접 생성하는 것이 아니라 외부(IoC 컨테이너)에서 생성한 후 주입시켜주는 방식이다. 의존성 주입을 통해 모듈 간의 결합도가 낮아지고 유연성이 높아진다.
  <br>
  (참고) 의존성 주입 방식 3가지 - 생성자 주입, 수정자 주입, 필드 주입
  <br>
</div>
</details>
<br>
