
# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">
<br>

#### POJO (Plain Old Java Object)
- POJO는 말 그대로 오래된 방식의 간단한 자바 객체로, 풀어서 설명하자면 특정 기술에 종속되어 동작하지 않는 순수한 자바 객체를 의미한다.   
- Java EE 등 중량 프레임워크들을 사용하게 되며 해당 프레임워크에 종속된 무거운 객체를 만들게 된 것에 반발해 사용되기 시작한 용어   
- 이후 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않은 자바 오브젝트를 지칭하는 말로 사용
- 스프링 프레임워크는 POJO 방식의 프레임워크
- 특정 기술과 환경에 종속하게 되면 유지보수와 확장성에 문제가 생김 → POJO 는 필요에 따라 재활용 가능
</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">
<br>

#### 제너릭 (Generic)
- 타입을 일반화하는 것
- 클래스 내부에서 개별적으로 타입을 지정하는 것이 아니라, 외부에서 지정하게끔 일반화시켜두는 것
- 사용자가 제너릭 클래스의 인스턴스를 생성할 때 혹은 제너릭 메서드를 호출할 때 타입을 정할 수 있다
```java
//제너릭 클래스 예시
public class example<T>{
    T obj;
    public example(T obj){
        this.obj = obj;
    }
}

//인스턴스 생성
Example<String> e1 = new Example("example");
Example<Integer> e2 = new Example(1234);
```

#### 컬렉션 클래스에서 제너릭을 사용하는 이유
1. 재사용성 → 여러 타입의 파라미터를 삽입해 객체를 생성할 수 있으므로 코드가 간결해지고 재사용성이 증가한다. 동일한 기능을 하는 메서드에서 파라미터 타입만 다르게 할 경우 제너릭 타입이 유용
2. 컴파일 시 타입 에러 발견 → 런타임 단계에서 문제가 발생될 가능성 방지
3. 형변환 과정 생략 → 컴파일 단계에서 컴파일러에 의해 자동으로 타입변환 되므로 코드에서 타입 캐스팅을 할 필요 X


</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">
<br>

#### 클래스 변수의 초기화
- 클래스 변수: static 변수, 클래스 별로 유일
- 클래스가 처음 메모리에 로딩될 때 단 한번 차례대로 수행한다.

#### 클래스 변수 초기화 순서
1. 클래스 변수의 기본값 → 클래스가 처음 로딩될 때 var는 0으로 기본값을 가진다.
2. 클래스 변수의 명시적 초기화 → 명시적 초기화 적용으로 var는 1이 된다.
3. 클래스 초기화 블럭 → 클래스 초기화 블럭에서 var는 2가 된다.

```java
class Example{
    static int var = 1;
    static{
        var = 2;
    }
}
```

</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">
<br>

#### 직렬화
- 자바 언어에서 사용되는 객체 또는 데이터를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림 형태로 연속적인 데이터로 변환하는 포맷 변환 기술
- JVM의 메모리에 상주되어있는 객체 데이터를 바이트 형태로 변환하는 기술

#### 역직렬화
- 바이트로 변환된 데이터를 원래대로 자바의 객체 또는 데이터로 변환하는 기술
- 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태

보통 직렬화된 바이트 형태의 데이터는 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역직렬화를 통해 자바 객체로 변환하여 JVM 메모리에 적재

#### 자바 직렬화의 사용 이유
- CSV, JSON, 프로토콜 버퍼 등은 시스템의 고유 특성과 상관없이 대부분의 시스템에서의 데이터 교환 시 많이 사용
- 자바 직렬화 형태의 데이터 교환은 자바 시스템 간의 데이터 교환을 위해 존재
- 자바 시스템에서의 개발에 최적화되어 있다.
- 데이터 타입이 자동으로 맞춰지기 때문에 역직렬화가 되면 기존 객체처럼 바로 사용 가능

#### 자바 직렬화의 사용처
- JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화가 필요할 때 사용
- 시스템이 종료되더라도 없어지지 않으며 영속화된 데이터이기 때문에 네트워크로 전송 가능
- 서블릿 세션, 캐시, 자바 RMI (Remote Method Invocation) 등에서 사용된다.
</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">
<br>

- SOLID 원칙은 객체 지향 설계에서 지켜줘야 할 5개의 소프트웨어 개발 원칙을 이른다.   
- SOLID 객체 지향 원칙을 적용 시 코드 확장과 유지보수 관리가 쉬워지며, 불필요한 복잡성을 제거해 리팩토링에 소요되는 시간이 줄어들어 개발의 생산성을 높일 수 있다.

#### SOLID 5가지 설계 원칙
1. SRP (Single Responsibility Principle) 단일 책임 원칙
    - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러 개 설계하라는 원칙이다.
    - SRP 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있다.
    - 최종적으로 단일 책임 원칙의 목적은 프로그램의 유지보수성을 높이기 위한 설계 기법이다.

3. OCP (Open Closed Principle) 개방-폐쇄 원칙
    - 클래스는 확장에 열려있어야 하며, 수정에는 닫혀있어야 한다는 원칙이다.
    - 기능 추가 요청이 오면 클래스 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화하도록 해야한다.

5. LSP (Liskov Substitution Principle) 리스코프 치환 원칙
    - 서브 타입은 언제든 기반 타입으로 교체할 수 있어야 한다는 원칙이다.
    - 부모 클래스가 들어갈 자리에 자식 클래스가 들어가도 계획대로 잘 동작해야하며,
    - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야 LSP를 만족한다.

7. ISP (Interface Segregation Principle) 인터페이스 분리 원칙
    - 인터페이스를 각 사용에 맞게끔 잘게 분리해야한다는 설계 원칙이다.
    - SRP 원칙이 클래스 분리를 통해 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계하는 것
    - ISP 원칙은 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표이다.

9. DIP (Dependency Inversion Principle) 의존 역전 원칙
    - 어떤 클래스를 참조해서 사용해야하는 상황이 생긴다면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소 (추상 클래스/인터페이스)를 참조하라는 원칙이다.
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다.
    - 자주 변화하는 대상보다 거의 변화가 없는 대상에 의존하라는 뜻이다.

</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">
<br>

#### DI (Dependency Injection): 의존성 주입
- 의존성: 하나의 객체가 자신이 해야하는 일을 하기 위해 다른 객체의 도움이 필수적인 관계   
   ex. 컨트롤러는 서비스 객체에 의존적 (dependent)
- 의존성 주입: A라는 클래스가 B라는 클래스를 사용하고 있을 때 (=의존하고 있을 때), A클래스에서 B클래스를 직접 생성해서 사용하는 것이 아니라 외부에서 B클래스의 인스턴스를 생성해서 주입해줌
- 제어의 역전 (IOC): A클래스에서 B클래스를 직접 참조하고 생성했던 것을 중간에 매개체를 하나 두고서 그 매개체를 통해서 사용하게 됨   
  → 기존에는 개발자가 직접 의존성을 제어하던 것을, 어떠한 매개체에게 제어권을 일임하게 되어 더이상 제어의 주체가 개발자가 아니게 되었기 때문에 제어의 역전이 발생했다고 한다.
- IOC Container: 개발자에게 일임받은 제어권을 사용하여 의존성을 관리, 인스턴스를 생성하여 주입, 메모리 해제 등의 역할을 한다. 주로 프레임워크가 이 역할을 담당. ex. spring container
</div>
</details>
<br>
