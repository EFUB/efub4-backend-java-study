
# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">

 #### POJO란 Plain Old Java Object의 약자로 오래된 방식의 간단한 자바 오브젝트란 뜻으로 <br /> Java EE등의 중량 프레임워크들을 사용하게 되면서<br /> 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용하게 된 용어이다.

 아래와 같이 가장 기본적인 형태의 Java객체를 POJO라고 한다.
 ```
 public class Pojo{
    private String name;
    private int age;

    public String getName(){
        return name;
    }
    public String getAge(){
        return age;
    }
    public void setName(String name){
        this.name = name;
    }
    public void setAge(int age){
        this.age = age;
    }
 }
 ```

EJB(Enterprise Java Beans) 등에서 사용되는 Java bean이 아닌 Getter,Setter로 구성된 가장 순수한 형태의 기본 클래스를 POJO라고 한다.

EJB의 사용과 프로그램의 규모 증가로 특정 기술과 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생기게 되고, 특정 기술의 클래스를 상속받거나,직접 의존하게 되어 확장성이 매우 떨어지며 객체지향성도 떨어졌다.

POJO 프레임워크는 POJO를 사용하는 장점과 EJB에서 제공하는 엔터프라이즈 서비스와 기술을 그대로 사용할 수 있도록 도와주는 프레임워크로 가장 대표적으로 언급되는게 스프링과 하이버네이트다.

## 스프링
- 엔터프라이즈 서비스들을 POJO 기반으로 만든 비즈니스 오브젝트에서 사용할 수 있게 해준다.
- IoC 컨테이너를 제공해서, 인스턴스들의 라이프 사이클을 관리한다.
- 특정 인터페이스를 구현하거나 상속할 필요 없이 라이브러리를 지원하기때문에 사용하기 쉬우며 객체 또한 가벼운 것이 특징이다.
- OOP를 더 객체 지향적으로 사용할 수 있게 해주는 AOP 기술을 적용해서 POJO 개발을 더 쉽게 만들어준다.<br /><br /> 

```
public class POJO{

    @Autowired
    UserRepository userRepository;

    private String name;
    private int age;

    public void test(){
        userRepository.findAll();
    }
}
```
- `@Autowired`를 활용하여 의존성 주입을 하여 느슨한 결합력을 가지면서, 직접적으로 `extends`, `implements`를 하지 않아도 해당 클래스에 접근할 수 있게 된다.
- 이 코드가 POJO를 무시한 코드에 비해 갖게 되는 장점은 extends를 하여 Override하여 작성하지 않아도 되면서 UserRepository 코드에 변경이 생겨도 같이 변하는 장점이 있다.

## 하이버네이트
- Persistence 기술과 오브젝트-관계형 DB 매핑을 순수한 POJO를 이용해 사용할 수 있게 만드는 POJO 기반 프레임워크
- JDBC API를 직접 사용해 개발하는 것 못지 않은 성능과 복잡한 퍼시스턴스 로직을 개발 가능하게 해준다
- 하이버네이트가 사용하는 POJO 엔티티들은 객체 지향적인 다양한 설계와 구현이 가능하다


## POJO 프로그래밍의 가치
#### POJO 기반의 코드인지를 확인하는 기준
#### 1.객체지향적으로 설계 되었는가?
반복적인 템플릿 코드와 테스트하기 힘든 구조, 확장 및 재활용의 어려움이 남아있다면 EJB의 문제점을 여전히 안고 있는 것이다.
#### 2. 테스트가 용이한가?
잘 만들어진 POJO 어플리케이션은 자동화된 테스트 코드 작성이 편리합니다. <br/>
코드 작성이 편리하면 좀 더 꼼꼼하게 만들게 되고, 코드 검증과 품질 향상에 유리해집니다. <br />
잘 만들어진 테스트 코드가 있다면 리팩토링할 여유가 생겨 POJO 코드를 좀 더 나은 설계구조로 변경할 수 있습니다.
#### 3. 특정 기술에 종속되어 있지 않은가?

<br /> <br />

### 진정한 POJO란?
객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">

### 제너릭이란?
다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. <br /> 다시 말해 특정 타입을 미리 지정하는 것이 아니라 필요에 따라 타입을 지정할 수 있도록 하는 일반 타입이라는 것이다.

### 제너릭의 장점
1. 타입 안정성을 제공한다.
2. 타입 체크와 형 변환을 생략할 수 있으므로 코드가 간결해진다.

### 제너릭 클래스
```
class Box<T>{
    T item;

    void setItem(T item){
        this.item = item;
    }
    T getItem(){
        return item;
    }
}
```
- 위와 같이 특정 타입 대신에 T와 같은 타입 변수를 붙이면 된다.
```
Box<String> b = new Box<String>();
b.getItem(new Object());
```
- 제너릭 클래스를 생성할 때는 참조 변수와 생성자 타입에 T 대신에 사용될 실제 타입을 지정해줍니다. (기본 타입 지정 불가)
<br /> 
<br />
- 다형성 적용 가능
<br /><br />

### 사용할 때 제한 사항
- 제너릭 클래스에 있는 static 멤버에 타입 변수 T를 사용할 수 없다.
  - static 멤버는 모든 객체에 대해 동일하게 동작해야하기 때문에 인스턴스 변수로 간주되는 T는 사용할 수 없습니다.
- 제너릭 타입의 배열은 생성할 수 없다.
    - 제너릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 `new T[10]`과 같이 배열을 생성하는 것은 허용하지 않는다. <- new 연산자가 컴파일 시점에 타입 T를 알아야하기 때문이다.
- 제너릭 클래스 Box<T>의 객체에는 T타입의 객체만 저장할 수 있다.
    - 객체를 생성할 때 참조변수와 생성자에 대입된 타입이 일치해야한다.
    - 두 타입이 상속된 관계에 있어도 에러가 발생한다.<br/>
    Apple이 Fruit의 자손이라고 하자 <br />
    `Box<Fruit> apple box = new Box<Apple>();` - 에러
    - 두 제너릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다.<br/> FruitBox는 Box의 자손이라고 합시다. <br/>
    `Box<Apple> applebox = new FruitBox<Apple>();` - 괜찮다


<br /><br />
### 컬렉션 클래스에서 제너릭을 사용하는 이유는 다양한 타입의 데이터를 저장하고 관리하기 위해서이다.<br />
예를 들어 `ArrayList`클래스는 배열을 이용해서 데이터를 저장하며, Object타입으로 모든 데이터를 다룰 수 있다. <br/>
그러나 이렇게 Object타입으로 데이터를 다루면, 런타임 시점에서 데이터 타입을 체크하기 어렵기 때문에 , 데이터 타입이 일치하지 않을 경우에는 런타임 에러가 발생할 수 있다. <br />
제너릭을 사용하여 `ArrayList`클래스를 정의하면 , 데이터 타입이 일치하는지 컴파일 시점에 체크할 수 있으며, 코드의 안정성을 높일 수 있다.<br/>
### 즉

1. 제너릭을 사용하면 컴파일 시점에서 타입 안전성을 보장할 수 있으며, 다양한 타입의 데이터를 다룰 수 있는 유연한 코드를 작성할 수 있다.
2. 컬렉션 클래스에서 제너릭을 사용하면 데이터 타입을 명확하게 지정할 수 있으며, 코드의 안전성과 유지 보수성을 높일 수 있다.

</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">

1. 기본값
2. 명시적 초기화
```
int door = 4;
Book book = new Book();
```
3. 클래스 초기화 블럭
```
class Example{

    static{ //클래스 초기화 블럭
       int start = 3;
    }
    //인스턴스 초기화 블럭
}
```

</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">

#### 직렬화(serialize)란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes)형태로 연속적인 데이터로 변환하는 포맷 변환 기술이다.
이를 시스템적으로 살펴보면 JVM의 Heap 혹은 Stack 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 전환하여 데이터베이스나 파일과 같은 외부 저장소에 저장해두고, 다른 컴퓨터에서 이 파일을 가져와 역직렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다.

### 직렬화 사용처
직렬화를 응용한다면 휘발성이 있는 캐싱 데이터를 영구 저장이 필요할 때 사용할 수 있다.<br/> 예를 들어 JVM의 메모리에서만 상주되어있는 객체 데이터가 시스템이 종료되더라도 나중에 다시 재사용될 수 있을 때 영속화(Persistence)를 해두면 좋다.
- 서블릿 세션(Servlet Session)
    - 단순히 세션을 서블릿 메모리 위에서 운용한다면 직렬화를 필요로 하지 않지만, 만일 세션 데이터를 저장하거나 공유하는 게 필요하다면 직렬화를 이용한다.
    - 세션 데이터를 데이터베이스에 저장할 때
    - 톰캣의 세션 클러스터링을 통해 각 서버 간에 데이터 공유가 필요할 때
<br />

- 캐시 <Cache>
    - 데이터베이스로부터 조회한 객체 데이터를 다른 모듈에서도 필요할 때, 재차 DB로 조회하는 것이 아닌, 객체를 직렬화하여 메모리나 외부 파일에 저장해두었다가 역직렬화하여 캐시 데이터로서 사용이 가능하다.
    - 자바 직렬화를 통해서만 캐시를 저장할 수 있는 것은 아니지만 자바 시스템에서만큼은 구현이 가장 간편하기 때문에 많이 사용된다고 보면 된다.
    - 단, 요즘은 Redis , Memcached와 같은 캐시 DB를 많이 사용하는 편이다.
    <br />

- 자바 RMI
    - 자바 RMI는 원격 시스템 간의 메세지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.
    - 이 메세지에 객체 데이터를 직렬화하여 송신하는 것이다.
    - 최근에는 소켓을 이용하기 때문에 안쓰이는 기술이다.

</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">

#### 객체 지향 설계의 5가지 원칙을 의미한다.

### 1. SRP(Single Responsibility principle), 단일 책임 원칙
소프트웨어를 설계할 때 객체는 단 하나의 책임만 가질 수 있다.<br />
객체가 하나의 책임을 가진다는 것은 새로운 기능이 확장되거나 변경사항이 있는 경우,  파급효과가 적다면 하나의 책임을 가지고 있는 것이다.
#### 즉 객체간의 응집도는 높고 결합도가 낮은 프로그램이라는 뜻이다.

### 2. OCP(Open/Closed Principle), 개방 폐쇄 원칙
소프트웨어가 기존의 코드를 변경하지 않고(Closed) 확장(Open)할 수 있다. <br />
인터페이스 안에 필요 기능을 작성한다면 인터페이스를 구현하는 구현 클래스는 다형성을 통해서 새로운 기능의 확장이 가능하다.
#### 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자가 필요한데, 스프링 프레임워크에서는 스프링 컨테이너가 이 역할을 한다.

### 3. LSP(Liskov substitution principle), 리스코프 치환 원칙
클래스를 상속하는 자식 클래스들은 부모 클래스의 규약을 지켜야한다.

### 4. ISP (Interface Segregation principle), 인터페이스 분리 원칙
어떤 구현 클래스는 자신이 구현하지 않는 인터페이스는 사용하지 않아야한다.

### 5. DIP(Dependency inversion principle), 의존 관계 역전 원칙
구현체보다는 인터페이스나 추상 클래스에 의존하는 것이 좋다. <br/><br/>
클라이언트가 기능을 이용할 때 인터페이스의 기능만 알고 그 안을 구현하는 구현체에 대해서는 몰라도 되는 것과 비슷한 원리이다.<br/>
구현체보다 인터페이스나 추상 클래스에 의존해야 기존 기능의 변경이나 새로운 요구사항을 통한 기능 확장이 되었을 때 유연한 변경이 가능하다.<br/>
여기서 OCP는 인터페이스와 구현체 둘 다 의존하는 것을 알 수 있는데 이는 DIP를 위반하는 것으로 볼 수 있다..<br/>
즉, 객체 지향 설게의 핵심은 다형성이지만, 다형성만으로는 OCP,DIP를 위반하는 경우가 발생한다.<br/>
스프링 프레임워크는 스프링이 지원하는 의존성 주입(DI)와 DI 컨테이너를 이용해 자바 객체의 의존성을 연동해준다.



</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">

#### Dependency Injection의 준말로 '의존성 주입'이라는 뜻을 가진다. <br/>
#### 스프링의 3가지 핵심 프로그래밍 모델중 하나로 외부에서 객체 간의 관계(의존성)을 결정해주어 객체를 직접 생성하는 것이 아니라 외부에서 생성 후 주입시켜주는 방식이다.

### 스프링 DI 3가지 방식
- Construct Injection(생성자 주입)
    - 가장 권장되는 의존 관계 주입 방식
    - 생성자 주입만이 final 키워드를 사용할 수 있다.
    - 객체의 불변성이 보장된다.
- Field Injection(필드 주입)
    - Bean으로 등록된 객체를 사용하고자 하는 클래스에 Field로 선언한 뒤 `@Autowired`를 붙여주면 자동으로 의존 관계가 주입된다.
    - 순환 참조를 막을 수 없다.
    - 생성자 이후에 호출 되므로 final를 사용할 수 없다.
    - 단일 책임 원칙을 위반한다.
    - Unit Test가 어렵다.
- Setter Injection(Setter 주입)
    - Null Pointer Exception이 발생할 수 있다.
</div>
</details>
<br>

참고 : <br/> https://wooj-coding-fordeveloper.tistory.com/80 <br/>
https://dev-coco.tistory.com/82 <br/>
https://velog.io/@offsujin/JAVA-%EC%A0%9C%EB%84%88%EB%A6%ADGeneric-%EC%9D%B4%EB%9E%80<br/>
https://yuniday2.tistory.com/82 <br />
https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A7%81%EB%A0%AC%ED%99%94Serializable-%EC%99%84%EB%B2%BD-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0
https://velog.io/@zayson/Spring-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8-3-SOLID-%EC%9B%90%EC%B9%99
https://backendcode.tistory.com/249