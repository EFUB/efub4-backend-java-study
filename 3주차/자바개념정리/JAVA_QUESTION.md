
# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">
  <ul>
    <li> POJO(Plain Old Java Object): 오래된 방식의 간단한 자바 오브젝트로, 주요 Java 오브젝트 모델, 컨벤션 또는 프레임워크를 따르지 않는 Java 오브젝트를 의미한다. 이상적인 POJO는 Java 언어 규약에 의해 강제된 것 이외의 제한에 구속되지 않는 Java 오브젝트이다.</li>
    <li>POJO 프로그래밍: 자바의 객체지향적인 특징을 살려 비지니스 로직에 충실한 개발이 가능하도록 하는 것이다. 1) 특정 규약이나 환경에 종속되어 있지 않은지 2) 객체지향적으로 설계되었는지 3) 테스트가 용이한지를 검토해 POJO 기반의 코드인지를 확인할 수 있다.</li>
  </ul>
</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">
  <ul>
    <li>제너릭(Generic): 클래스나 메서드를 정의할 때 타입을 파라미터화할 수 있는 기능을 말한다. 다시 말해, 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법이다.</li>
    <li>컬렉션 클래스: 여러 개의 값을 저장하고 관리하는 클래스. 컬렉션의 구현을 돕기 위한 클래스를 말하며, 컬렉션은 데이터를 담을 수 있는 일종의 컨테이너를 의미한다.</li>
    <li>컬렉션 클래스에서 제너릭을 사용하는 이유: 1) 재사용성 증가: 여러 타입의 파라미터를 삽입해 객체를 생성할 수 있기 때문에 코드 재사용성을 높일 수 있다. 2) 코드의 안전성:  컴파일 시 타입이 결정되기 때문에 런타임 단계에 타입 문제가 발생된 가능성을 방지해 보다 안전한 프로그래밍이 가능하다. 3) 컴파일러가 타입 변환 수행: 컴파일 단계에서 컴파일러가 타입 캐스팅을 수행해준다. </li>
  </ul>
</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">
  <ul>
    <li>클래스 변수의 초기화: 클래스 변수는 static 키워드로 선언되는 클래스의 모든 인스턴스가 공유하는 변수. 클래스 변수는 처음 메모리에 로딩될 때 단 한번 차레대로 수행된다. </li>
    <li>클래스 멤버 변수 초기화 순서: 정적 변수 및 정적 블록 -> 인스턴스 변수 및 인스턴스 초기화 블록 -> 생성자 순서로 초기화가 진행된다. </li>
  </ul>
</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">
  <ul>
    <li>직렬화(serialization): 데이터 구조나 오브젝트 상태를 동일하거나 다른 컴퓨터 환경에 저장(이를테면 파일이나 메모리 버퍼에서, 또는 네트워크 연결 링크 간 전송)하고, 나중에 재구성할 수 있는 포맷으로 변환하는 과정을 의미한다.</li>
    <li>자바에서의 직렬화: 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 말한다. 시스템 적으로는 JVM(Java Virtual Machine)의 메모리에 상주(heap 또는 stack) 되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태를 의미한다.</li>
    <li>자바 직렬화를 사용하는 이유: 자바 직렬화는 같은 자바 시스템에서의 데이터 전송(다른 JVM 환경의 시스템으로의 전송), 저장에 최적화되어 있다. 데이터 구조가 복잡하더라도 직렬화의 기본 조건만 지키면 직렬화와 역직렬화가 가능하다.</li>
  </ul>
</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">
  <ul>
    <li>SOLID: 객체 지향 설계의 다섯 가지 설계 원칙을 나타낸다.</li>
    <li>단일 책임의 원칙(SRP, Single Responsibility Principle): 클래스가 변경되어야 할 이유는 오직 하나여야 한다. 즉, 하나의 클래스는 하나의 기능만을 담당하며, 변경이 발생할 때는 한 가지 이유만 갖는다.</li>
    <li>개방 폐쇄 원칙(OCP, Open-Closed Principle): 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 유연하지만 수정에 대해서는 폐쇄적이어야 한다. 기능 추가 요청이 오면 손쉽게 확장하면서, 이에 따른 수정은 최소화하도록 프로그램을 작성한다.</li>
    <li>리스코프 치환 원칙(LSP, Liskov Substitution Principle): 부모 클래스는 항상 자식 클래스로 대체할 수 있어야 한다. 다형성의 특징을 이용하기 위한 원칙이다.</li>
    <li>인터페이스 분리 원칙(ISP, Interface Segegation Principle): 필요하지 않은 요소를 구현하지 않고, 가능한 최소한의 인터페이스만을 사용해야 한다. 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것을 목표로 가진다.</li>
    <li>의존 역전 원칙(DIP, Dependency Inversion Principle): 상위 모듈이 하위 모듈에 의존해서는 안 되며, 양쪽 모두 추상화에 의존해야 한다. 거의 변화가 없는 추상 클래스 및 인터페이스에 의존하는 것이 바람직하다.</li>
  </ul>
</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">
  <ul>
    <li>의존성 주입(Dependency Injection, DI): 다른 클래스에 의존해 객체를 주입받는 것으로, 제어의 역전을 구현하기 위해 사용한다. 스프링의 경우 클래스에서 객체를 직접 생성하는 것이 아니라 스프링 컨테이너에서 객체를 주입받아 사용할 수 있다. </li>
    <li>DI의 장점: 1) 의존성 감소: 주입받는 대상이 변하더라도 구현 자체를 수정할 일이 없거나 줄어든다. 2) 재사용성 및 가독성 증가, 테스트하기 좋은 코드가 된다. </li>
  </ul>
</div>
</details>
<br>
